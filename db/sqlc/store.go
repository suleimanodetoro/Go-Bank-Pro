package db

import (
	"context"
	"database/sql"
	"fmt"
)

// Store provides all functions needed to execute DB transactions.
// It extends the Queries struct generated by SQLC to enable the use of transactions.
type Store struct {
	// *Queries is a pointer to a Queries struct. This enables Store to "inherit" all the methods
	// generated by SQLC for querying the database.
	// Composition is used here instead of inheritance, which is Go's way of reusing functionality.
	*Queries

	// db is a pointer to a sql.DB object, which represents a database connection pool.
	// We'll use this to create transactions.
	db *sql.DB
}

// NewStore creates a new Store object.
// It takes a pointer to a sql.DB object as its argument, which is used to initialize the Store's db field.
// The New function (generated by SQLC) initializes and returns a pointer to a new Queries object.
func NewStore(db *sql.DB) *Store {
	return &Store{
		db:      db,      // Assign the passed-in db to the Store's db field.
		Queries: New(db), // Call the New function to initialize Queries with the db connection and assign the result (a *Queries) to the Queries field.
	}
}

// execTx is a method of Store that allows executing a function inside a database transaction.
// It takes two arguments:
// - ctx: A context object that allows us to set timeouts or cancellation signals for long-running transactions.
// - fn: A function that takes a pointer to a Queries object (*Queries) and returns an error.
//
// This method ensures that all the operations within the passed function `fn` are executed within
// a database transaction. If anything goes wrong, the transaction is rolled back. Otherwise, it is committed.
func (store *Store) execTx(ctx context.Context, fn func(*Queries) error) error {
	// Begin a new transaction with context (ctx) and options (nil means default options are used).
	tx, err := store.db.BeginTx(ctx, nil) // store.db is the database connection pool from the Store struct.
	if err != nil {
		// If starting the transaction failed, return the error immediately.
		return err
	}

	// The New function generates a new Queries object that uses the current transaction (tx) instead of the default database connection.
	// `q` is a pointer to this new Queries object.
	q := New(tx) // We pass `tx` (the transaction) to New, which returns a *Queries object for executing queries inside the transaction.

	// Execute the passed function `fn`, passing in the pointer `q` to the Queries object that is tied to this transaction.
	// This function will typically perform some database operations, and return an error if something goes wrong.
	err = fn(q) // We call the function `fn` that was passed to execTx, giving it access to the transactional Queries object `q`.

	if err != nil {
		// If the function `fn` returned an error, we attempt to rollback the transaction.
		// If rollback itself fails, we return a compound error containing both the original error (err) and the rollback error.
		if rbErr := tx.Rollback(); rbErr != nil {
			// fmt.Errorf formats a string that contains both the original error and the rollback error.
			return fmt.Errorf("tx error: %v, rollback error: %v", err, rbErr)
		}

		// If rollback was successful, return the original error from `fn`.
		// This allows the caller to handle the error that occurred during the execution of the transaction.
		return err
	}

	// If everything went well (no errors), commit the transaction.
	// If committing the transaction fails, return the commit error.
	return tx.Commit() // Commit finalizes the transaction, ensuring all operations inside the transaction are persisted to the database.
}
